<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>光之微</title>
  
  <subtitle>迎接光的洗礼</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-22T13:44:49.895Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>OCCJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原码反码补码</title>
    <link href="http://example.com/undefined/undefined.html"/>
    <id>http://example.com/undefined/undefined.html</id>
    <published>2023-07-22T05:05:14.041Z</published>
    <updated>2023-07-22T13:44:49.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-机器数和机器数的真值"><a href="#一-机器数和机器数的真值" class="headerlink" title="一. 机器数和机器数的真值"></a>一. 机器数和机器数的真值</h1><p>在学习原码，反码和补码之前， 需要先了解机器数和真值的概念。</p><h2 id="1、机器数"><a href="#1、机器数" class="headerlink" title="1、机器数"></a>1、机器数</h2><p>一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用机器数的最高位存放符号，正数为0，负数为1。</p><p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 100 00011 。</p><p>那么，这里的 0000 0011 和 1000 0011 就是机器数。</p><h2 id="2、机器数的真值"><a href="#2、机器数的真值" class="headerlink" title="2、机器数的真值"></a>2、机器数的真值</h2><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。</p><p>例如上面的有符号数 1000 0011，其最高位1代表负，其真正数值是 -3，而不是形式值131（1000 0011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001的真值 &#x3D; +000 0001 &#x3D; +1，1000 0001的真值 &#x3D; –000 0001 &#x3D; –1</p><h2 id="二-原码-反码-补码的基础概念和计算方法"><a href="#二-原码-反码-补码的基础概念和计算方法" class="headerlink" title="二. 原码, 反码, 补码的基础概念和计算方法"></a>二. 原码, 反码, 补码的基础概念和计算方法</h2><p>在探求为何机器要使用补码之前，让我们先了解原码、反码和补码的概念。对于一个数，计算机要使用一定的编码方式进行存储，原码、反码、补码是机器存储一个具体数字的编码方式。</p><ol><li>原码</li></ol><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如：如果是8位二进制：</p><p>[+1]原&#x3D; 0000 0001</p><p>[-1]原&#x3D; 1000 0001</p><p>第一位是符号位，因为第一位是符号位，所以8位二进制数的取值范围就是：（即第一位不表示值，只表示正负。）</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><p>原码是人脑最容易理解和计算的表示方式。</p><ol start="2"><li><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2></li></ol><p>反码的表示方法是：</p><p>正数的反码是其本身；</p><p>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</p><p>[+1] &#x3D; [0000 0001]原&#x3D; [0000 0001]反</p><p>[-1] &#x3D; [1000 0001]原&#x3D; [1111 1110]反</p><p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。</p><ol start="3"><li><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2></li></ol><p>补码的表示方法是：</p><p>正数的补码就是其本身；</p><p>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)</p><p>[+1] &#x3D; [0000 0001]原&#x3D; [0000 0001]反&#x3D; [0000 0001]补</p><p>[-1] &#x3D; [1000 0001]原&#x3D; [1111 1110]反&#x3D; [1111 1111]补</p><p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。</p><h2 id="三-为何要使用原码、反码和补码"><a href="#三-为何要使用原码、反码和补码" class="headerlink" title="三. 为何要使用原码、反码和补码"></a>三. 为何要使用原码、反码和补码</h2><p>在开始深入学习前，我的学习建议是先”死记硬背”上面的原码，反码和补码的表示方式以及计算方法。</p><p>现在我们知道了计算机可以有三种编码方式表示一个数，对于正数因为三种编码方式的结果都相同：</p><p>[+1] &#x3D; [0000 0001]原&#x3D; [0000 0001]反&#x3D; [0000 0001]补</p><p>所以不需要过多解释，但是对于负数：</p><p>[-1] &#x3D; [10000001]原&#x3D; [11111110]反&#x3D; [11111111]补</p><p>可见原码，反码和补码是完全不同的。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？</p><p>首先, 因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。(真值的概念在本文最开头) 但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单，计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂！</p><p>于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即：1-1 &#x3D; 1 + (-1) &#x3D; 0， 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。</p><p>于是人们开始探索将符号位参与运算，并且只保留加法的方法。</p><p>首先来看原码：</p><p>计算十进制的表达式： 1 - 1 &#x3D; 0</p><p>1 - 1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原+ [1000 0001]原&#x3D; [1000 0010]原&#x3D; -2</p><p>如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。</p><p>为了解决原码做减法的问题， 出现了反码：</p><p>计算十进制的表达式：1 - 1 &#x3D; 0</p><p>1 - 1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原+ [1000 0001]原&#x3D; [0000 0001]反+ [1111 1110]反&#x3D; [1111 1111]反&#x3D; [1000 0000]原&#x3D; -0</p><p>发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在”0”这个特殊的数值上，虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。</p><p>于是补码的出现，解决了0的符号问题以及0的两个编码问题：</p><p>1-1 &#x3D; 1 + (-1) &#x3D; [0000 0001]原+ [1000 0001]原&#x3D; [0000 0001]补+ [1111 1111]补&#x3D; [1 0000 0000]补&#x3D;[0000 0000]补&#x3D;[0000 0000]原注意：进位1不在计算机字长里。</p><p>这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128：-128的由来如下：</p><p>(-1) + (-127) &#x3D; [1000 0001]原+ [1111 1111]原&#x3D; [1111 1111]补+ [1000 0001]补&#x3D; [1000 0000]补</p><p>-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补就是-128，但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。(对-128的补码表示[1000 0000]补，算出来的原码是[0000 0000]原，这是不正确的)</p><p>使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。</p><p>因为机器使用补码，所以对于编程中常用到的有符号的32位int类型，可以表示范围是: [-2^31, 2^31-1] 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。</p><h2 id="四-原码-反码-补码-再深入"><a href="#四-原码-反码-补码-再深入" class="headerlink" title="四 原码, 反码, 补码 再深入"></a>四 原码, 反码, 补码 再深入</h2><p>计算机巧妙地把符号位参与运算，并且将减法变成了加法，背后蕴含了怎样的数学原理呢？</p><p>将钟表想象成是一个1位的12进制数。如果当前时间是6点，我希望将时间设置成4点，需要怎么做呢？我们可以：</p><ol><li><p>往回拨2个小时：6 - 2 &#x3D; 4</p></li><li><p>往前拨10个小时：(6 + 10) mod 12 &#x3D; 4</p></li><li><p>往前拨10+12&#x3D;22个小时：(6+22) mod 12 &#x3D;4</p></li></ol><p>上面2,3方法中的mod是指取模操作，16 mod 12 &#x3D;4，即用16除以12后的余数是4。</p><p>所以钟表往回拨(减法)的结果可以用往前拨(加法)替代！</p><p>现在的焦点就落在了如何用一个正数，来替代一个负数呢？上面的例子我们能感觉出来一些端倪，发现一些规律。但是数学是严谨的，不能靠感觉。</p><h2 id="首先介绍一个数学中相关的概念：同余"><a href="#首先介绍一个数学中相关的概念：同余" class="headerlink" title="首先介绍一个数学中相关的概念：同余"></a>首先介绍一个数学中相关的概念：同余</h2><p>同余的概念</p><p>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余。</p><p>记作 a ≡ b (mod m)</p><p>读作 a 与 b 关于模 m 同余。</p><p>举例说明：</p><p>4 mod 12 &#x3D; 4</p><p>16 mod 12 &#x3D; 4</p><p>28 mod 12 &#x3D; 4</p><p>所以4，16，28对于模 12 同余。</p><h2 id="负数取模"><a href="#负数取模" class="headerlink" title="负数取模"></a>负数取模</h2><p>正数进行mod运算是很简单的，但是负数呢？</p><p>下面是关于mod运算的数学定义：</p><p>上面是截图，”取下界”符号找不到如何输入(word中粘贴过来后乱码)。下面是使用”L”和”J”替换上图的”取下界”符号：</p><p>x mod y &#x3D; x - y L x &#x2F; y J</p><p>上面公式的意思是:</p><p>x mod y等于 x 减去 y 乘上 x与y的商的下界。</p><p>以 -3 mod 2 举例:</p><p>-3 mod 2</p><p>&#x3D; -3 - 2xL -3&#x2F;2 J</p><p>&#x3D; -3 - 2xL-1.5J</p><p>&#x3D; -3 - 2x(-2)</p><p>&#x3D; -3 + 4 &#x3D; 1</p><p>所以:</p><p>(-2) mod 12 &#x3D; 12-2&#x3D;10　　　　(-2) mod 12 &#x3D; -2 - 12x[-2&#x2F;12] &#x3D; -2 - 12x(-1) &#x3D; -2 + 12 &#x3D; 10</p><p>(-4) mod 12 &#x3D; 12-4 &#x3D; 8　　　　(-4) mod 12 &#x3D; -4 - 12x[-4&#x2F;12] &#x3D; -2 -12x(-1) &#x3D; -4 + 12 &#x3D; 8</p><p>(-5) mod 12 &#x3D; 12 - 5 &#x3D; 7　　　 (-5)mod 12 &#x3D; -5 - 12x[-5&#x2F;12] &#x3D; -5 -12x(-1) &#x3D; -5 + 12 &#x3D; 7</p><p>开始证明</p><p>再回到时钟的问题上：</p><p>回拨2小时 &#x3D; 前拨10小时</p><p>回拨4小时 &#x3D; 前拨8小时</p><p>回拨5小时&#x3D; 前拨7小时</p><p>注意，这里发现的规律！</p><p>结合上面学到的同余的概念，实际上：</p><p>(-2) mod 12 &#x3D; 10</p><p>10 mod 12 &#x3D; 10</p><p>-2与10是同余的。</p><p>(-4) mod 12 &#x3D; 8</p><p>8 mod 12 &#x3D; 8</p><p>-4与8是同余的。</p><p>距离成功越来越近了。要实现用正数替代负数，只需要运用同余数的两个定理：</p><p>反身性：</p><p>a ≡ a (mod m)</p><p>这个定理是很显而易见的。</p><p>线性运算定理：</p><p>如果a ≡ b (mod m)，c ≡ d (mod m) 那么：</p><p>(1)a ± c ≡ b ± d (mod m)</p><p>(2)a * c ≡ b * d (mod m)</p><p>所以：</p><p>7 ≡ 7 (mod 12)</p><p>(-2) ≡ 10 (mod 12)</p><p>7 -2 ≡ 7 + 10 (mod 12)</p><p>现在我们为一个负数，找到了它的正数同余数。但是并不是7-2 &#x3D; 7+10，而是 7 -2 ≡ 7 + 10 (mod 12) ，即计算结果的余数相等。</p><p>接下来回到二进制的问题上，看一下：2-1&#x3D;1的问题。</p><p>2-1&#x3D;2+(-1) &#x3D; [0000 0010]原+ [1000 0001]原&#x3D; [0000 0010]反+ [1111 1110]反</p><p>先到这一步，-1的反码表示是1111 1110。如果这里将[1111 1110]认为是原码，则[1111 1110]原 &#x3D; -126，这里将符号位除去，即认为是126。</p><p>发现有如下规律：</p><p>(-1) mod 127 &#x3D; 126</p><p>126 mod 127 &#x3D; 126</p><p>即：</p><p>2 ≡ 2 (mod 127)</p><p>(-1) ≡ 126 (mod 127)</p><p>2-1 ≡ 2+126 (mod 127)</p><p>2-1 与 2+126的余数结果是相同的！而这个余数，正式我们的期望的计算结果：2-1&#x3D;1</p><p>所以说一个数的反码，实际上是这个数对于一个模的同余数。而这个模并不是我们的二进制，而是所能表示的最大值！这就和钟表一样，转了一圈后总能找到在可表示范围内的一个正确的数值！</p><p>而2+126很显然相当于钟表转过了一轮，而因为符号位是参与计算的，正好和溢出的最高位形成正确的运算结果。</p><p>既然反码可以将减法变成加法，那么现在计算机使用的补码呢？为什么在反码的基础上加1，还能得到正确的结果？</p><p>2-1&#x3D;2+(-1) &#x3D; [0000 0010]原+ [1000 0001]原&#x3D; [0000 0010]补+ [1111 1111]补</p><p>如果把[1111 1111]当成原码，去除符号位，则：</p><p>[0111 1111]原&#x3D; 127</p><p>其实，在反码的基础上+1，只是相当于增加了模的值：</p><p>(-1) mod 128 &#x3D; 127</p><p>127 mod 128 &#x3D; 127</p><p>2 ≡ 2 (mod 128)</p><p>2-1 ≡ 2+127 (mod 128)</p><p>此时，表盘相当于每128个刻度转一轮。所以用补码表示的运算结果最小值和最大值应该是[-128, 128]。</p><p>但是由于0的特殊情况，没有办法表示128，所以补码的取值范围是[-128, 127]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-机器数和机器数的真值&quot;&gt;&lt;a href=&quot;#一-机器数和机器数的真值&quot; class=&quot;headerlink&quot; title=&quot;一. 机器数和机器数的真值&quot;&gt;&lt;/a&gt;一. 机器数和机器数的真值&lt;/h1&gt;&lt;p&gt;在学习原码，反码和补码之前， 需要先了解机器数和真值的概</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/undefined/undefined.html"/>
    <id>http://example.com/undefined/undefined.html</id>
    <published>2023-07-12T12:38:21.522Z</published>
    <updated>2023-07-12T12:38:21.522Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
